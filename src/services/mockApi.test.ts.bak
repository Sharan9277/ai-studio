import { generateImage, ApiClient } from './mockApi';

const mockMathRandom = jest.spyOn(global.Math, 'random');

describe('mockApi', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    jest.clearAllTimers();
    jest.useFakeTimers();
    mockMathRandom.mockReset();
  });

  afterEach(() => {
    jest.useRealTimers();
  });

  describe('generateImage', () => {
    const mockRequest = {
      imageDataUrl: 'data:image/png;base64,test',
      prompt: 'test prompt',
      style: 'editorial' as const,
    };

    test('successfully generates image when not error condition', async () => {
      mockMathRandom
        .mockReturnValueOnce(0.1) // shouldError = false
        .mockReturnValueOnce(0.5) // delay
        .mockReturnValueOnce(0.5) // image selection
        .mockReturnValueOnce(0.5); // id generation

      const promise = generateImage(mockRequest);
      jest.advanceTimersByTime(2000);

      const result = await promise;

      expect(result).toHaveProperty('id');
      expect(result).toHaveProperty('imageUrl');
      expect(result.prompt).toBe('test prompt');
      expect(result.style).toBe('editorial');
      expect(result).toHaveProperty('createdAt');
      expect(result.id).toMatch(/^gen_/);
    });

    test('throws error when in error condition', async () => {
      mockMathRandom
        .mockReturnValueOnce(0.5) // shouldError = true
        .mockReturnValueOnce(0.5); // delay

      const promise = generateImage(mockRequest);
      jest.advanceTimersByTime(2000);

      await expect(promise).rejects.toThrow(
        'Model overloaded. Please try again.'
      );
    });

    test('can be aborted with AbortSignal', async () => {
      const controller = new AbortController();
      const promise = generateImage(mockRequest, controller.signal);

      controller.abort();

      await expect(promise).rejects.toThrow('Request aborted');
    });

    test('throws abort error if already aborted', async () => {
      const controller = new AbortController();
      controller.abort();

      await expect(
        generateImage(mockRequest, controller.signal)
      ).rejects.toThrow('Request aborted');
    });
  });

  describe('ApiClient', () => {
    const mockRequest = {
      imageDataUrl: 'data:image/png;base64,test',
      prompt: 'test prompt',
      style: 'editorial' as const,
    };

    test('retries on failure with exponential backoff', async () => {
      const client = new ApiClient();

      mockMathRandom
        .mockReturnValueOnce(0.5) // First attempt fails
        .mockReturnValueOnce(0.5) // delay
        .mockReturnValueOnce(0.5) // Second attempt fails
        .mockReturnValueOnce(0.5) // delay
        .mockReturnValueOnce(0.1) // Third attempt succeeds
        .mockReturnValueOnce(0.5) // delay
        .mockReturnValueOnce(0.5) // image selection
        .mockReturnValueOnce(0.5); // id generation

      const promise = client.generateWithRetry(mockRequest, 3);

      jest.advanceTimersByTime(2000); // First attempt
      jest.advanceTimersByTime(1000); // First backoff
      jest.advanceTimersByTime(2000); // Second attempt
      jest.advanceTimersByTime(2000); // Second backoff
      jest.advanceTimersByTime(2000); // Third attempt

      const result = await promise;
      expect(result).toHaveProperty('id');
    });

    test('gives up after max attempts', async () => {
      const client = new ApiClient();

      mockMathRandom
        .mockReturnValueOnce(0.5) // First attempt fails
        .mockReturnValueOnce(0.5) // delay
        .mockReturnValueOnce(0.5) // Second attempt fails
        .mockReturnValueOnce(0.5); // delay

      const promise = client.generateWithRetry(mockRequest, 2);

      jest.advanceTimersByTime(2000); // First attempt
      jest.advanceTimersByTime(1000); // First backoff
      jest.advanceTimersByTime(2000); // Second attempt

      await expect(promise).rejects.toThrow(
        'Model overloaded. Please try again.'
      );
    });

    test('can abort ongoing generation', async () => {
      const client = new ApiClient();
      const promise = client.generateWithRetry(mockRequest);

      client.abort();

      await expect(promise).rejects.toThrow('Request aborted');
    });

    test('tracks generation state correctly', () => {
      const client = new ApiClient();

      expect(client.isGenerating()).toBe(false);

      client.generateWithRetry(mockRequest);
      expect(client.isGenerating()).toBe(true);

      client.abort();
      expect(client.isGenerating()).toBe(false);
    });
  });
});